import { useState, useEffect, useCallback, useRef } from 'react';
import { useAuth } from '../useAuthSimple';
import { useCompany } from '../../contexts/CompanyContext';
import { apiClient } from '../../services/apiClient';
import { InboxConversation, InboxTab } from '../../types/inbox.types';

export interface Message {
    id: string;
    content: string;
    senderId: string;
    senderName: string;
    timestamp: Date;
    type: 'text' | 'image' | 'file' | 'video' | 'audio' | 'template' | 'IMAGE' | 'FILE' | 'VIDEO' | 'AUDIO' | 'TEMPLATE';
    isFromCustomer: boolean;
    status: 'sending' | 'sent' | 'delivered' | 'read' | 'error';
    conversationId: string;
    fileUrl?: string;
    fileName?: string;
    fileSize?: number;
    isAiGenerated?: boolean;
    metadata?: any;
    attachments?: any[];
}

// Helper to safely parse dates
const safeDate = (date: any): Date => {
    if (!date) return new Date();
    try {
        const parsed = new Date(date);
        if (isNaN(parsed.getTime())) {
            return new Date();
        }
        return parsed;
    } catch (e) {
        return new Date();
    }
};

// Helper to parse messages (unified logic)
const parseMessage = (msg: any): Message => {
    let isAiGenerated = false;
    let md: any = null;

    if (msg.metadata) {
        try {
            md = typeof msg.metadata === 'string' ? JSON.parse(msg.metadata) : msg.metadata;
            isAiGenerated = md.isAIGenerated || md.isAutoGenerated || md.source === 'ai_agent' || false;
        } catch (e) {
            // Failed to parse metadata, continue with default values
        }
    }

    // Determine sender name
    let senderName = 'Ø§Ù„Ø¹Ù…ÙŠÙ„';
    if (!msg.isFromCustomer) {
        if (isAiGenerated) {
            senderName = 'Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ';
        } else if (md?.employeeName) {
            senderName = md.employeeName;
        } else if (msg.sender?.name && msg.sender.name !== 'Ù…ÙˆØ¸Ù') {
            senderName = msg.sender.name;
        } else {
            senderName = 'Ù…ÙˆØ¸Ù';
        }
    }

    // Parse attachments if string
    let attachments = msg.attachments;
    if (typeof attachments === 'string') {
        try {
            attachments = JSON.parse(attachments);
        } catch (e) {
            attachments = [];
        }
    }

    const msgType = msg.type || 'text';
    const isMedia = ['image', 'file', 'video', 'audio', 'IMAGE', 'FILE', 'VIDEO', 'AUDIO'].includes(msgType);

    return {
        id: msg.id,
        content: msg.content,
        senderId: msg.sender?.id || msg.senderId || 'unknown',
        senderName,
        timestamp: safeDate(msg.timestamp || msg.createdAt),
        type: msgType,
        isFromCustomer: msg.isFromCustomer,
        status: 'delivered', // Default to delivered for history
        conversationId: msg.conversationId,
        fileUrl: msg.fileUrl || (isMedia ? msg.content : undefined),
        fileName: msg.fileName,
        fileSize: msg.fileSize,
        isAiGenerated,
        metadata: md,
        attachments: attachments
    };
};

export const useInboxConversations = () => {
    const { user: _user } = useAuth();
    const { companyId } = useCompany();

    const [conversations, setConversations] = useState<InboxConversation[]>([]);
    const [selectedConversation, setSelectedConversation] = useState<InboxConversation | null>(null);
    const [messages, setMessages] = useState<Message[]>([]);
    const [loading, setLoading] = useState(true);
    const [loadingMessages, setLoadingMessages] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [messagesPage, setMessagesPage] = useState(1);
    const [hasMoreMessages, setHasMoreMessages] = useState(false);

    // Conversations pagination & filtering
    const [conversationsPage, setConversationsPage] = useState(1);
    const [hasMoreConversations, setHasMoreConversations] = useState(false);

    // Track current tab for pagination to work correctly
    const currentTabRef = useRef<string>('all');

    const currentConversationIdRef = useRef<string | null>(null);

    // Store counts from API
    const [apiCounts, setApiCounts] = useState<{ total: number; unreplied: number }>({ total: 0, unreplied: 0 });

    // Load conversations
    const loadConversations = useCallback(async (pageNum = 1, append = false, tab: string = 'all', search?: string) => {
        if (!companyId) return;

        try {
            if (pageNum === 1) {
                setLoading(true);
                currentTabRef.current = tab; // Update current tab
            }
            setError(null);

            const response = await apiClient.get(`conversations`, {
                params: {
                    companyId,
                    limit: tab === 'unreplied' ? 1000 : 50, // Fetch all unreplied conversations, limit others for performance
                    page: pageNum,
                    tab: tab,
                    ...(search && search.trim() ? { search: search.trim() } : {}) // ðŸ†• Add search parameter
                }
            });

            const result = response.data || {};
            const data = result.data || result || [];
            const pagination = result.pagination || {};
            const counts = result.counts || {};

            // Update API counts
            if (counts.total !== undefined || counts.unreplied !== undefined) {
                setApiCounts(prev => ({
                    total: counts.total ?? prev.total,
                    unreplied: counts.unreplied ?? prev.unreplied
                }));
            }

            // Check for more conversations
            setHasMoreConversations(pagination.hasNextPage || pagination.hasMore || false);
            setConversationsPage(pageNum);

            const formattedConversations: InboxConversation[] = data.map((conv: any) => {
                // Determine tab logic moved to backend ideally, mapping here for safety
                // ... logic to determine tab ...
                let currentTab: InboxTab = 'all';
                const status = (conv.status || 'active').toLowerCase();

                if (status === 'resolved' || status === 'done') {
                    currentTab = 'done';
                } else if (status === 'active' || status === 'open' || status === 'pending') {
                    let metadataTab = null;
                    if (conv.metadata) {
                        try {
                            const metadata = typeof conv.metadata === 'string' ? JSON.parse(conv.metadata) : conv.metadata;
                            metadataTab = metadata.tab || metadata.inboxTab;
                        } catch (e) {
                            // ignore parse errors
                        }
                    }
                    if (metadataTab && ['main', 'general', 'requests', 'spam'].includes(metadataTab)) {
                        currentTab = metadataTab as InboxTab;
                    } else {
                        currentTab = 'main';
                    }
                }

                return {
                    id: conv.id,
                    customerId: conv.customerId,
                    customerName: conv.customer?.name || conv.customerName || 'Ø¹Ù…ÙŠÙ„',
                    customerAvatar: conv.customer?.avatar || conv.customerAvatar,
                    lastMessage: conv.lastMessage || 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø±Ø³Ø§Ø¦Ù„',
                    lastMessageTime: safeDate(conv.lastMessageTime || conv.updatedAt),
                    unreadCount: conv.unreadCount || 0,
                    platform: 'facebook' as const,
                    tab: currentTab,
                    status: status === 'resolved' || status === 'done' ? 'done' : status === 'pending' ? 'pending' : 'open',
                    assignedTo: conv.assignedTo || null,
                    assignedToName: conv.assignedToName || null,
                    tags: conv.tags || [],
                    priority: conv.priority || false,
                    snoozedUntil: conv.snoozedUntil ? safeDate(conv.snoozedUntil) : null,
                    archived: conv.archived || false,
                    muted: conv.muted || false,
                    lastStatusChange: safeDate(conv.lastStatusChange || conv.updatedAt),
                    firstResponseTime: conv.firstResponseTime || null,
                    avgResponseTime: conv.avgResponseTime || null,
                    pageName: conv.pageName,
                    pageId: conv.pageId,
                    aiEnabled: (() => {
                        if (conv.hasOwnProperty('aiEnabled') && conv.aiEnabled !== undefined) return conv.aiEnabled;
                        if (conv.metadata) {
                            try {
                                const metadata = typeof conv.metadata === 'string' ? JSON.parse(conv.metadata) : conv.metadata;
                                return metadata.aiEnabled !== false;
                            } catch (e) { return true; }
                        }
                        return true;
                    })(),
                    lastMessageIsFromCustomer: conv.lastMessageIsFromCustomer,
                    hasUnreadMessages: conv.hasUnreadMessages,
                    postId: (() => {
                        if (conv.postId) return conv.postId;
                        if (conv.metadata) {
                            try {
                                const metadata = typeof conv.metadata === 'string' ? JSON.parse(conv.metadata) : conv.metadata;
                                return metadata.postId || null;
                            } catch (e) { return null; }
                        }
                        return null;
                    })(),
                    postDetails: null,
                };
            });

            // Deduplicate
            const conversationsMap = new Map<string, InboxConversation>();
            formattedConversations.forEach(conv => {
                conversationsMap.set(conv.id, conv);
            });
            const deduplicatedConversations = Array.from(conversationsMap.values());

            if (append && pageNum > 1) {
                setConversations(prev => {
                    const existingIds = new Set(prev.map(c => c.id));
                    const newConversations = deduplicatedConversations.filter(c => !existingIds.has(c.id));
                    return [...prev, ...newConversations];
                });
            } else {
                setConversations(deduplicatedConversations); // Replace entirely for new page or tab switch
            }

        } catch (err: any) {
            console.error('âŒ Error loading conversations:', err);
            setError(err.message || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª');
        } finally {
            if (pageNum === 1) {
                setLoading(false);
            }
        }
    }, [companyId]);

    // Load more conversations - now uses currentTabRef to ensure correct pagination
    const loadMoreConversations = useCallback(() => {
        if (hasMoreConversations && !loading) {
            loadConversations(conversationsPage + 1, true, currentTabRef.current);
        }
    }, [hasMoreConversations, loading, conversationsPage, loadConversations]);

    // Load messages for a conversation
    const loadMessages = useCallback(async (conversationId: string, pageNum = 1) => {
        if (!conversationId || !companyId) return;

        if (pageNum === 1) {
            currentConversationIdRef.current = conversationId;
            setMessages([]);
        } else if (currentConversationIdRef.current !== conversationId) {
            return;
        }

        try {
            setLoadingMessages(true);

            const response = await apiClient.get(`/conversations/${conversationId}/messages`, {
                params: {
                    companyId,
                    page: pageNum,
                    limit: 50
                }
            });

            if (currentConversationIdRef.current !== conversationId) return;

            const result = response.data || {};
            const data = result.data || result || [];
            const pagination = result.pagination || {};

            setHasMoreMessages(pagination.hasNextPage || pagination.hasMore || false);
            setMessagesPage(pageNum);

            const formattedMessages: Message[] = data.map(parseMessage);

            // Deduplicate
            const messagesMap = new Map<string, Message>();
            formattedMessages.forEach(msg => messagesMap.set(msg.id, msg));
            const deduplicatedMessages = Array.from(messagesMap.values());

            if (pageNum === 1) {
                setMessages(deduplicatedMessages);
            } else {
                setMessages(prev => {
                    const existingIds = new Set(prev.map(m => m.id));
                    const newMessages = deduplicatedMessages.filter(m => !existingIds.has(m.id));
                    const result = [...newMessages, ...prev];
                    return result;
                });
            }

        } catch (err: any) {
            console.error('âŒ Error loading messages:', err);
            setError(err.message || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„');
        } finally {
            setLoadingMessages(false);
        }
    }, [companyId]);

    const loadMoreMessages = useCallback(() => {
        if (selectedConversation && hasMoreMessages && !loadingMessages) {
            loadMessages(selectedConversation.id, messagesPage + 1);
        }
    }, [selectedConversation, hasMoreMessages, loadingMessages, messagesPage, loadMessages]);

    // Select conversation
    const selectConversation = useCallback(async (conversation: InboxConversation | null) => {
        setSelectedConversation(conversation);
        if (conversation) {
            // ðŸ†• Save selected conversation ID to localStorage for persistence after refresh
            localStorage.setItem('selectedConversationId', conversation.id);

            loadMessages(conversation.id);
            // ðŸ”§ FIX: Always mark conversation as read when opened (even if unreadCount is 0, to sync with backend)
            // This ensures backend state is updated and unreadCount is recalculated
            try {
                const response = await apiClient.post(`/conversations/${conversation.id}/read`);
                // Update local state with response data
                // ðŸ”§ FIX: Use unreadCount from response (backend calculates it correctly)
                const newUnreadCount = response.data?.unreadCount ?? response.data?.conversation?.unreadCount ?? 0;
                setSelectedConversation(prev => prev ? { ...prev, unreadCount: newUnreadCount } : null);
                setConversations(prev => prev.map(conv =>
                    conv.id === conversation.id ? { ...conv, unreadCount: newUnreadCount } : conv
                ));
            } catch (error: any) {
                console.error('Failed to mark conversation as read:', error);
            }
        } else {
            // ðŸ†• Clear saved conversation ID when deselecting
            localStorage.removeItem('selectedConversationId');
            setMessages([]);
            currentConversationIdRef.current = null;
        }
    }, [loadMessages, companyId, setConversations]);

    // Update selected conversation from list updates
    useEffect(() => {
        if (selectedConversation && conversations.length > 0) {
            const updatedConversation = conversations.find(c => c.id === selectedConversation.id);
            if (updatedConversation && (
                updatedConversation.status !== selectedConversation.status ||
                updatedConversation.assignedTo !== selectedConversation.assignedTo ||
                updatedConversation.assignedToName !== selectedConversation.assignedToName ||
                updatedConversation.priority !== selectedConversation.priority ||
                updatedConversation.postId !== selectedConversation.postId
            )) {
                const postDetails = selectedConversation.postDetails || updatedConversation.postDetails || null;
                setSelectedConversation({
                    ...updatedConversation,
                    postDetails: postDetails
                });
            }
        }
    }, [conversations, selectedConversation]);

    // Initial load - load default 'all' tab if not called externally
    // But since component calls it, we might want to skip auto-load or default to something
    useEffect(() => {
        // We let the component trigger the first load to control the tab
    }, []);

    // ðŸ†• Restore selected conversation from localStorage after conversations are loaded
    const restoredRef = useRef(false);
    useEffect(() => {
        if (restoredRef.current || conversations.length === 0 || selectedConversation) return;

        const savedConversationId = localStorage.getItem('selectedConversationId');
        if (savedConversationId) {
            const savedConversation = conversations.find(c => c.id === savedConversationId);
            if (savedConversation) {
                console.log('ðŸ”„ Restoring saved conversation:', savedConversationId);
                selectConversation(savedConversation);
                restoredRef.current = true;
            }
        }
    }, [conversations, selectedConversation, selectConversation]);

    // Selection state
    const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());

    const toggleSelection = useCallback((id: string) => {
        setSelectedIds(prev => {
            const next = new Set(prev);
            if (next.has(id)) next.delete(id);
            else next.add(id);
            return next;
        });
    }, []);

    const selectAll = useCallback((ids: string[]) => {
        setSelectedIds(new Set(ids));
    }, []);

    const clearSelection = useCallback(() => {
        setSelectedIds(new Set());
    }, []);

    const addMessage = useCallback((newMessage: any) => {
        setMessages(prev => {
            // Check if message already exists by ID
            if (prev.some(m => m.id === newMessage.id)) return prev;

            const formatted = parseMessage(newMessage);

            // ðŸ†• Check for optimistic message with same content (temp_ ID)
            // If we find a temp message with same content, replace it with real message
            const tempIndex = prev.findIndex(m =>
                m.id.startsWith('temp_') &&
                m.content === formatted.content &&
                !m.isFromCustomer
            );

            if (tempIndex !== -1) {
                // Replace temp message with real message
                const updated = [...prev];
                updated[tempIndex] = formatted;
                return updated;
            }

            // ðŸ†• Also check if same content was sent within last 5 seconds (duplicate prevention)
            const now = new Date().getTime();
            const isDuplicate = prev.some(m =>
                m.content === formatted.content &&
                !m.isFromCustomer &&
                (now - new Date(m.timestamp).getTime()) < 5000
            );

            if (isDuplicate) return prev;

            return [...prev, formatted];
        });
    }, []);

    const updateSelectedConversation = useCallback((updates: Partial<InboxConversation>) => {
        setSelectedConversation(prev => prev ? { ...prev, ...updates } : null);
        setConversations(prev => prev.map(conv =>
            conv.id === selectedConversation?.id ? { ...conv, ...updates } : conv
        ));
    }, [selectedConversation?.id]);

    // ðŸ†• Add a single conversation to the list (for URL loading)
    const addConversationToList = useCallback((conversation: InboxConversation) => {
        setConversations(prev => {
            // Check if conversation already exists
            if (prev.some(c => c.id === conversation.id)) {
                // Update existing conversation
                return prev.map(c => c.id === conversation.id ? conversation : c);
            }
            // Add to beginning of list
            return [conversation, ...prev];
        });
    }, []);

    // ðŸ†• Update messages status to 'read' (for read receipts)
    const markMessagesAsRead = useCallback((watermark: number) => {
        setMessages(prev => prev.map(msg => {
            // Only update outgoing messages (not from customer) that are sent/delivered
            if (!msg.isFromCustomer &&
                (msg.status === 'sent' || msg.status === 'delivered') &&
                new Date(msg.timestamp).getTime() <= watermark) {
                return { ...msg, status: 'read' as const };
            }
            return msg;
        }));
    }, []);

    return {
        conversations,
        selectedConversation,
        messages,
        loading,
        loadingMessages,
        error,
        selectConversation,
        loadConversations,
        loadMessages,
        loadMoreMessages,
        addMessage,
        hasMore: hasMoreMessages,
        hasMoreConversations,
        loadMoreConversations,
        updateSelectedConversation,
        selectedIds,
        toggleSelection,
        selectAll,
        clearSelection,
        apiCounts,
        // ðŸ†• Add conversation to list
        addConversationToList,
        // ðŸ†• Mark messages as read (for read receipts)
        markMessagesAsRead
    };
};
